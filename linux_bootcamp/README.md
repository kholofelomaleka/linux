Linux Fundamentals - Summary

1. Directory Structure
/ 	: "Root" - top file system hierarchy
/bin	: Binary and other executable programs/files - Machine readable files
/etc 	: System config files - OS and Apps config files are here
/home	: User home directory, separates user files
/opt 	: Optional or 3rd party software is installed here
/tmp 	: Temporary files that get cleared at boot
/usr 	: User related programs and executables, e.g. /usr/bin
/var 	: Variable data generated by system or directories, e.g. log files

- Other directories
/boot	: Files needed to boot the OS
/cdrom 	: Mount point for CD-ROMS
/cgroups: Control groups hierarchy
/dev	: Device files, typically controlled by OS and Sys Admins
/sbin 	: System admin binaries
/selinux: Used to display info about the SELinux
/srv	: Data served by the system
/srv/www: Web server files
/srv/ftp: FTP files
/sys	: Used to display and configure devices known to the Linux kernal

2. The Shell
Default user interface to the system, e.g. terminal
This is a command line interpreter, that takes commands and executes them

- The Prompt - Accepts commands, $ normal user and # root user
- Root, Superuser - Restricted to system administrators
		  - Required when installing, starting/stopping apps
- Tilde Expantsion - "~" which takes you to the user home directory

3. Basic Linux Commands
- ls
- cd
- pwd - present working dir
- cat
- echo
- man - displays online manual
- exit
- clear

4. Getting Help at CLI

- PATH - Environment variable that controls the command search path and contains the list of dirs

5. Working with Directories
Containers for files and other dirs
. this dir
.. parent dir
cd - changes to previous dir

- Creating and Removing Directories
mkdir [-p] dir -- creates a dir
rmdir [-p] dir -- removes a dir
rm -rf dir -- recursively removes dirs
-- the -p creates/removes the parent dirs

6. Understanding LS
- ls -lastrh
- * is an executable
- @ is a link
- / is a dir

- ls -R (similar to tree command)
- ls -ld (shows only directories)
- ls -F (file types)

7. File and Directory Permissions

-r -- read
-w -- write
-x -- execute

- Permission Categorie
u - user
g - group
o - other
a - all

- Changing Permissions
Permissions are also known as modes i.e. chmod
- chmod -- Change mode command
- ugoa -- user, group, other, all
- +-= -- add, remove, set
- rwx -- read, write, execute

- Numeric Based Permissions
r	w	x
0	0	0	vale for off
1	1	1	value for off
4	2	1	base 10 value for on

8. Finding Files and Directories

- Find Command
-name pattern -- files and dirs matching pattern
-iname pattern -- like -name, but ignores case
-ls -- preforms ls on each of the found items
-mtime days -- finds files days old
-size num -- finds files num old
-newer file -- finds files newer than file
-exec command {} \; -- run command against all files found

e.g. find files that are > 10 days but < than 20 days
-- find . -mtime +10 -mtime -20

- Locate Command
Faster than find but uses an index... therefore the locate may not find recent files

9. Viewing Files

cat - display content of file
more - browse text file
less - like more, with more features
head - top 10
tail - bottom
vimtutor



Intermediate Linux Skills - Summary

10. Wildcards

- * -- matches zero or more characters e.g. \*.txt.
- ? -- matches exactly one character e.g. ?.txt
- [] -- Character class, matches any character between the brackets 
	- e.g. ca[nt] will find cat, or can
  [!] -- matches characters NOT in the brackets
	- e.g. [!aeiou]\* will find characters NOT starting with "aeiou"
- \ -- escape character

- Ranges
Use  2 characters separated by a hyphen to create a range in the character class
-- [a-g]\* -- matches all files starting with a to g
-- [3-6]\* -- matchas everything from 3 till 6

- Named Character Classes
-- [[:alpha:]] - alphabetical letters
-- [[:alnum:]] - all upper, lower and numbers
-- [[:digit:]] - 0 to 9
-- [[:lower:]]
-- [[:space:]] - spaces, tabs, and new line spaces
-- [[:upper:]] 

11. Input/Output Types

Standard input (stdin) - 0
Standard output (stdout) - 1
Standard error (stderr) - 2

12. Redirection

Redirect output to a file - >
Redirect output and append to an existing file - >>
Redirect input from file to command - <

e.g.
& -- used with redirection to signal that a file descriptor is being used.
2>&1 -- combines stderr and stdout (send both stderr & stdout to a file, e.g. ls file1 file2 > out.both 2>&1)
2>file -- Redirects stderr to a file
2>/dev/null -- Redirects stderr to dev null

13. Comparing files
- diff - compare 2 files, e.g. diff file1 file2
- sdiff - side-by-side comparison, e.g. sdiff file1 file2
- vimdiff - hilights differences in vim, e.g. vimdiff file1 file2

--> therefore, ACTION = (A)dd (C)hange (D)elete
--> 3c3 - means line number 3 in file1 (C)hanged from line 3 in file2

14. Searching in Files using Pipes

- To look for text matching a pattern:
-- strings -- displays printable strings in Binary Files

-- grep	-i --ignore case
	-c --count ocurrences
	-n -- line number that matches
	-v -- invertet, not matched

- Cut out selected portions of a file, if file is omitted, use as standard input.
-- cut [file]
	-d -- Use delimiter as the field separator
	-f N -- display the nth field, e.g. -f2,3,4 to print filed 2,3 and 4

- The file Command
-- file <file_name> -- display the file type

- Pipes
-- |
-- command-output | command-input
e.g. grep <pattern_output> <input_file>, therefore cat file | grep <pattern>

- Paging utilities
-- more 
-- less

15. Copying Files over the Network
- SCP	- Secure copy
	- scp <file_name> <remote_destination> e.g. scp file1 localhost.localdomain:/home
	- scp <remote_file> <local_destination> e.g. scp localhost.localdomain:/home/file1 /home/

- SFTP	- SSH file transfer protocol
	- use clients like putty, winscp ...
	- e.g. sftp localhost.localdomain to login,
	- lls - list files in local working dir
	- lpwd - shows working dir

- ftp 	- Not secure like scp sftp, password and files not encrypted

16. Processes & Job Control

- ps command	- ps -e -- display all processes.
		- ps -ef -- display all processes, full.
		- ps -eH -- display a process tree.
		- ps -e --forest -- display a process tree.
		- ps -u <username> -- display users's processes.

- Background and Foreground Processes
-- command & 	- Start command in the background
-- ctrl-c	- Kill the foreground process
-- ctrl-z 	- Suspend the foreground process, this stops the process... to send it to the background use:
		  - bg [%num]	- background a suspended process.
		  - fg [%num]	- foreground a background process.
		  - kill 	- kill a process using job number or PID.
		  - jobs [%num]	- list jobs. e.g. jobs %1
- kill [-sig] pid - Sends a signal to a process.
		  - e.g. kill -15 [pid]

17. Installing, Uninstalling Softeware (RedHat, Fedora, CentOS, Oracle Linux, Scientific Linux)
- Package (software) 	- A collection of files (Data/Metadata) that includes Description, Version and Dependencies.
- Package Manager  	- Installs, upgrades, removes packages.
			- Manages dependencies.
			- Keeps track of what is installed.
-- yum
	- yum search [string]	- search for a package.
	- yum info [package]	- display info
	- yum install [-y] package - install package
	- yum remove package	- uninstall
-- rpm
	- rpm -qa package	- list package files.
	- rpm -ivh package.rpm 	- install.




18. THE LINUX BOOT PROCESS AND SYSTEM LOGGING
18.1 BIOS (Basic Input/Output System)
- Special firmware - used in the boot process
- OS Independent, therefore it is not unique to the Linux OS
- Its Primary purpose is to find and execute the boot loader
- Performs the POST
-- Power-On Self Test - Performs basic checks on various hardware components (CPU, Memory, & Storage devices)

18.2 Boot Loaders
- LILO - LInux LOader (older systems, replaced by GRUB)
- GRUB - GRand Unified Bootloader (replaced LILO)
- Boot loaders start the OS
- Boot loaders can start the OS with different options

18.3 Initial RAM Disk
- initrd 
- Temporary filesystem that is loaded from disk and stored in memory
- Contains helpers and modules(drivers) required to load the permanent OS filesystems.

18.4 Kernel Ring Buffer
- Always the same size, deletes old messages to make room for new files
- Contains messages from the Linux kernal (dmesg command, found on /var/log/dmesg)

18.5 Runlevels / Description
- 0 	Shuts down system
- 1,S,s	Single user mode, for maintenance
- 2 	Multi-user mode with graphical interface (Deb/Ubuntu)
- 3	Multi-user text mode (RedHat/CentOS)
- 4 	Unified
- 5	Multi-user mode with graphical interface (RedHat/CentOS)
- 6 	Reboot

18.6 Systemd
- Uses targets instead of runlevels.
-- to set target --> systemctl set-default <target_name> --uses systemctl
		     Or, cd /etc/systemd/system/default/<target_name>

18.7 Rebooting
- telenit 6
- systemctl isolate reboot.target
- reboot

- Shutdown (shutdown -r Hh:Mn "mesage")

19. System Logging
- Aids in the processing of messages
- Allows logging to be centrally controlled.
- Useful facilities and severities to categorize messages.

19.1 Syslog Servers
- Process syslog messages based on rules
- syslogd
- rsyslog (/etc/rsyslog.conf)
- syslog-ng

19.2 Logging Rules
- Selector field
-- FACILITY.SEVERITY
-- mail.\*
-- mail
-- FACILITY.none
-- FACILITY.SERVERITY; FACILITY_2.SERVERITY

- Action field
-- Determines how a message is processed

-e.g. Write any mail.\* logs to mail.log
-- mail.\* 	/var/log/mail.log

19.3 Caching vs Non-Caching 
- Caching is used if the path starts with a hyphen (all less sever logs can use caching)
-- mail.info 	-/var/log/mail.info
- Messages can be lost during a system crash if caching mode is used. 
- Using caching mode can improve I/O performance





20. Disk Management

20.1 Partitios
- Allow the separation of data into partition schemes:
-- 1) OS	
-- 2) Application
-- 3) User
-- 4) Swap, or
-- 5) User home directories
- To protect overall system, and keep users from filling up the root directory and causing outages.

20.2 Master Boot Record (MBR) - A boot sector at the beginning of a storage device.
     The partition table in the MBR contains information on how the logical partitions are organised on the disk.
- Can only address 2 TB disk space therefore, being phased out by GUID Partition Table (GPT).
- 4 Primary partitions (Maximum) or use extended partition.
- Extended partitions allow you to create logical partitions

20.3 GUID Partition Table (GPT)
- GUID = Global Unique Identifier
- Replaceing MBR partition scheme
- Part of Unified Extensible Firmware Interface (UEFI)
- UEFI is replacing BIOS
- Supports up to 128 partitions, up to 9.4ZB disk size.
- Not supported by older OS and may require newer or special tools

20.4 Mount Points
- A directory used to access data on partitions.
- / (slash/root) is always a mount point
- /home = /home/db2inst is mounted on /home

20.5 fdisk
- Used to mount partitions, alternatives are, gdisk, parted.
-- Creating partitions:
--> fdisk -l -- displays a list of available devices
--> fdisk <partition_name> -- to work with the /dev/sda/ partition
 
 
21. File Systems
- Before you can use a partition, it needs a File System.
-- ext = Extended File System (created specially for linux, and default)
-- ext2, ext3, ext4 are later releases.

- Other types:
-- ReiserFS
-- JFS
-- XFS
-- ZFS
-- Btrfs

- Creating FS's:
--> mkfs -t TYPE DEVICE -- e.g. mkfs -t ext3 /dev/sdb2 

- Mounting FS's
--> mount DEVICE MOUNT_POINT -- e.g. mount /dev/sdb3 /opt
-- NB!! Manually mounting a FS will not persist between reboots, 
   therefore to make mounts persist between reboots, add an entry in the /etc/fstab file

- Unmounnting FS's
--> umount DEVICE_OR_MOUNT_POINT -- e.g. umount /opt, or umount /dev/sdb3

- How to perpare swap space for use
-- Prep the swap area and enable it:
   --> mkswap PARTITION; swapon PARTITION; swapon -s -- e.g. mkswap /dev/sdb1; swapon /dev/sdb1; swapon -s

- FS table (/etc/fstab)
-- Controls where devices are mounted and what options are used.
-- Each entry is made up of 6 fields
-- 1) device,
-- 2) mount point,
-- 3) file system type,
-- 4) mount options,
-- 5) dump, 
-- 6) fsck order

- Disk UUIDs and Labels
-- To view lables and uuid's use:
--> lsblk -f
--> blkid

-- To label a FS use the e2label command.


22. Logical Volume Manager
- Provides an extra layer of ebstraction between the disk or storage devices on the system and the file systems

-- Layers of abstraction
--> Physical Volume (PV) 
--  Storage devices used by LVM, They do not have to be physical, as long as the system can see the device

--> Volume Group (VG)
-- Made up of one or more PV's... Pool of storage.  To increase, add more PV's.

--> Logical Volumes (LV)
-- Created from a VG, then File systems are created on these Logical Volumes
---- LV's can also be devided into LOGICAL EXTENTS (another layer of abstraction)
---- LE's -- A collection of LE's make up a LV.  This is how LVM allows us to resize LV's, the LVM just changes the number of extents for that LV

- Flexible Capacity
-- File Systems can extend across multiple storage devices
-- Aggregate multiple storage devices into a single logical volume.

- Resize Storage While Online
-- Expand or shrink file systems in real-time while data remains online and fully accessible

- Online Data Relocation
-- Easily migrate data from one storage device to another while online

- Convenient Device Naming
-- Human-readable device names, e.g. /dev/vg_database/lv_db_logs

- Data Striping
-- Increase throughput by allowing your system to read data in parallel

- Data Redundancy / Data Mirroring
-- Increase fault tolerance and reliability by having more than one copy of your data

- Snapshots
-- Create point-in-time snapshots of your filesystems.

- Examples Creating Logical Volumes Process
-- 1. Check available storage devices
	-> lvmdiskscan -- Shows the storage devices that have the ability to be used by LVM
	-> lsblk -- Check where root is mounted (lsblk -p, for more info) 
	-> fdisk -l -- Shows disks attached to system

-- 2. Create PV.
	-> pvcreate -- initialises a disk for use by LVM. e.g. pvcreate /dev/sdb
	-> pvs -- Check initialised disks

-- 3. Create VG.
	--> vgcreate vg_name pv_name. e.g. vgcreate vg_data /dev/sdb
	--> vgs -- display VGs

-- 4. Create a LV
	--> lvcreate -L 20G -n lv_name vg_name. e.g. lvcreate -L 20G -n lv_data vg_data
	--> lvcreate -l 5118 -n lv_name vg_name -- alternatively using extents
	--> lvs -- display the LVs
	--> lvdisplay -- Provides more detail

-- 5. Create FS and Mount
	--> mkfs -t ext4 path_to_lv. e.g. mkfs -t ext4 /dev/vg_data/lv_data
	--> mkdir mount_point. e.g. mkdir /data
	--> mount mount_path mount_point. e.g. mount /dev/vg_data/lv_data /data
	--> add entry to /dev/fstab to mount on boot

22.1 Extending VG's - PRACTICAL EXERCISE

-- 1. Add extra storage
	-> Add storage to Virtual Machine

-- 2. Initialise disk for use by LVM
	-> pvcreate /dev/sdd(new storage)

-- 3. Increase volume group storage (vg_database)
	-> vgextend vg_database /dev/sdd
	-> vgs - checking if its added (PV = 2)

-- 4. Increase the FS
	-> lvextend -L +10G -r path_to_lv (/dev/vg_name_lv_name)
	--> If -r is left out, you can use the resize tool
	--> resize2fs path_to_lv (/dev/vg_name_lv_name)

23. Mirroring Logical Volumes
- Exact copy of data will be stored on more than one disk
--> lvcreate -m 1(how many copies of data) -L 5G -n lv_name vg_name -- will create LV that syncronises data to another disk--> lvs -a --> See the "Attr" column

23. Removing LVs, PVs, & VGs
--> umount /mount_point. e.g. umount /data
--> lvremove lv_name. e.g. lvremove /dev/vg_data/lv_data

- To remove PV's
--> vgreduce vg_name -- free up the vg, to be used by other lv or delete
--> pvremove pv_name -- remove it from LVM

24. Migrating data from one Storage Device to Another
- Data and files remain online
-- Add the new PV - pvcreate
-- Add to VG - vgextend
-- Migrate the data - pvmove souce_pv target_pv


25. User Management

25.1 Managing users and groups


26. Networking
- TCP/IP
-- Used for network communications
-- TCP = Transmission Control Protocol 
	- Controls data exchange
-- IP = Internet Protocol
	- Sends data from one device to another
-- Hosts
	- Devices on a network that have an IP address

- IP Networking
- For a device on a networ to communicate, it needs:
-- IP Address
	- e.g. 199.83.131.186
-- Subnet Mask
	- e.g. 255.255.255.0
-- Broadcast Address
	- e.g. 199.83.131.255
-- octet.octet.octet.octet (8 bits)
	- octet values can be from 0 to 255

- IP Addresses consist of two parts, 
	1. Network address - Tells routers what networks the host belongs to, and where to route data that is destined for that host.
	2. Host address - Tells the routers the specific device the data should be delivered to.  For routing to work properly, each device(network) needs a unique network address, and each device needs to have a unique host address.

- Classful Networks
-- Address Classes determines what portion is used as a Network address and what portion is Host address.
-- A class determinses the possible number of network and the addressible space per network. e.g. Class a can have 16 777 261 mill hosts. 
e.g. CLASS	NETWORK			HOSTS ALLOWED
	A	1.0 - 127.0		16,777,261	e.g. 17.24.88.9
	B	128 - 191.255		65,536		e.g. 183.194.46.31
	C	192.0.0 - 233.255.255	255		e.g. 199.83.131.181

- Subnet Masks
-- The network part of the IP address corresponds to the 255 in the subnet mask.
-- e.g. the first octet of a class A network is the network portion, and the remaining three octets are the host portion.
For class B networks, the first 2 octets are the network portion, and the remaining two are for the host.  And class C networks, the first 3 octets belong to the network portion, while the last octet belongs to the host.
e.g. CLASS 	SUBNET MASK
	A	255.0.0.0
	B	255.255.0.0
	C	255.255.255.0
e.g. 183.194.46.31 - This will be a class B network, since it falls in the range of 128.o to 191.255
the network portion is:
 255.255(network portion)         0.0(host portions)
 183.194 and the host portion is 46.31.  

- Broadcast Addresses
-- This is a special logical address used to send data to all hosts on a given network.  In addition to their own IP addresses, all network hosts recieve data sent to the broadcast address.
To determine the broadcast address, replace the 0's with 255 in the octets in the subnet mask. 
e.g. CLASS	NETWORK		SUBNET MASK 	BROADCAST
	A	17.0.0.0	255.0.0.0	17.255.255.255
	B	183.194.0.0	255.255.0.0	183.194.255.255
	C	199.83.131.0	255.255.255.0	199.83.131.255
 
- CIDR (CLASSLESS INTER-DOMAIN ROUTING)
-- This allows addresses to be subdevided regardles of their traditional classes
-- The subdivided networks are called subnets.
-- IP: 121.67.198.94
	- Class A network: 121.0.0.0
	- Class A subnet: 255.0.0.0
	- Class A broadcast: 121.255.255.255
-- If you specify a subnet mask, you can alter tghe portion of the if address that is used as the network and the part that is used as the host address... by specifying the below netwok:
-- IP: 121.67.198.94 Subnet: 255.255.255.0
	- CIDR network: 121.67.198.0
	- CIDR subnet: 255.255.255.0
	- CIDR broadcast: 121.67.198.255

- Private Address Space
-- There are ranges that are reserved for privete address space.
-- Non-routable ip adresses that cannot be routed to the internet.  also reffered to the rfc1918 addresses (rfc standard document defined in 1918). These can be subnetted how ever way you want.
e.g. CLASS 	RANGE				PRIVATE ADDRESS SPACE
	A	1.0.0.0 - 127.255.255.255	10.0.0.0 - 10.255.255.255
	B	128.0.0.0 - 191.255.255.255	172.16.0.0 - 172.31.255.255
	C	192.0.0.0 - 233.255.255.255	192.168.0.0 - 192.168.255.255

-- NETWORKING
- Determine the IP Address
-- ip a - ip address command
 
- ip and ifconfig utilities - configure network 
-- ifconfig tool

- hostnames
-- A host is a device connected to a network... therefore a hostname is a human readable name for an ip address.
e.g. webprod01 = 10.109.155.174
-- To display a hostname, run:
--> hostname, uname -n, hostname -f

- To set the hostname: 
--> vi /etc/sysconfig/network and set HOSTNAME=new_hostname 

- DNS and name resolution
-- The DNS is used to translate human readable hostnames to ip addresses.
--> FQDN = Fully qualified domain name
	- webprod01.mycompany.com
--> TLD = Top level domain 
	- .com, .net, .org, .local, etc...
--> Domains
	- to the left of TLD.
--> Sub-Domain
	- to the left of the domain

- Resolving DNS Names
--> host - host <hostname> e.g. host www.google.com
--> dig - dig <hostname> e.g. dig www.google.com

- /etc/hosts
-- This file consists of a list of ip addresses and hostnames
-- The Format:
	- IP 	FQDN alias(es) e.g. 10.11.12.13	  webdev01.mycompany.com   webdev01
	- this will allow you to refer to the host by name e.g. webdev01 or webdev01.mycompany.com
-- It is local to the linux system and does not propagate to the rest of the network.

- /etc/nsswitch.conf
-- By default the /etc/hosts file is checked first before a DNS server is queried, to change this you can edit the /etc/nsswitch.conf
-- NSS = Name Service Switch - Controls the order in which lookups are performed.


27. Networking - DHCP, Dynamic and Static Addressing
- Network Ports
-- Ports are used to identify a service on a port.  When a service starts it binds itself to a port, and listens to incoming traffic destined for the port.
-- Ports 1 - 1023 are well-known ports (system ports or privileged ports). Unpriveleged ports (> 1023) can be used by any service and dont need sudo privileges to be opened. 
--> 22 - ssh, 25 - SMTP, 80 - HTTP, 143 - IMAP, 389 - LDAP, 443 - HTTP
--> /etc/services

- DHCP = Dynamic Host Configuration Protocol
-- DHCP servers assign ip address to DHCP clients on a network:
-- When a client wants to request an ip address, it sends a broadcast message looking for a dhcp server.  The dhcp server then responds to the client with:
	- IP Address
	- netmask
	- gateway
	- DNS server to use for name resolution
-- the dhcp client then configures itself with this info and begins to communicate on the network.

-- Each IP is "leased" from the pool of IP addresses the DHCP server manages.
 - The lease expiration time is configurable on the dhcp server (1hr, 1day, 1week, etc...)
 - The client must renew the lease if it wants to keep the ip address, and if no renewal is recieved, the IP is available to another dhcp client.

-- Configuring a DHCP Client - RHEL
--> ifconfig -a or ip link
--> /etc/sysconfig/network-scripts/ifcfg-DEVICE_NAME
--> Set the BOOTPROTO="dhcp"

-- Configuring a DHCP Client - Ubuntu
--> /etc/network/interfaces 
--> Add dhcp to the inet address statement. e.g. iface eth0 inet dhcp

- Static IP Addresses
-- Assign Static IP address - RHEL
/etc/sysconfig/network-scripts/ifcfg-DEVICE_NAME
DEVICE="enp0s3"
BOOTPROTO="static"
IPADDR="10.109.155.174"
NETMASK="255.255.255.0"
NETWORK="10.109.155.0"
BROADCAST=10.109.155.255"
GATEWAY="10.109.155.1"
ONBOOT="yes"

-- Assign Static IP address - UBUNTU
/etc/network/interfaces
auto eth0
iface eth0 inet static
	address 10.109.155.174
	netmask	255.255.255.0
	gateway 10.109.155.1

- Manually Assigning an IP Address
-- Format (ip command):
-> ip address add IP[/NETMASK] dev NETWORK_DEVICE. e.g.
-> ip address add 10.109.155.174 dev eth0, or
-> ip address add 10.109.155.174/255.255.255.0 dev eth0
-> ip link set eth0 up

-- Format (ifconfig tool):
-> ifconfig NETWORK_DEVICE addr netmask SUBNET_MASK. e.g.
-> ifconfig eth0 10.109.155.174, or
-> ifconfig eth0 10.109.155.174 netmask 255.255.255.0
-> ifconfig eth0 up

- ifup / ifdown - Scripts used to configure changes
-- Can be used instead of ifconfig / ip
-- Use configuration files
--> e.g. ifup eth0
	 ifup enp5s2
	 ifdown eth0
	 ifdown enp5s2

- GUI / TUI tools
- RedHad
	- nmtui
	- system-config-network
- SUSE
	- YaST
- Ubuntu


28. Troubleshooting Networks
-- Large topic, how you approach the situation depends on the circumstances and encvironment.
-- Looking at a problem from multiple angles using multiple tools and drawing a conclusion.
The most common tools for diagnostics:

-- ping - test network connectivity
-->  If you have trouble connecting to a host over the network, the first thing to try is the ping command.  This command sends 1 or more icmp packets that you specify and wait for a resposnse.
--> e.g. ping -c COUNT HOST - ping -c 5 www.google.com
---> If you can ping with the ip and not the hostname, this means theres a problem with the resolution of the dns name.
---> If the host/ip is unreachable, it doesnt mean there's a problem with it. second step,
---> try to ping something else, and if theres' no response, there's a problem with my host, check:
---> network cable, network drivers, or check if the network service has been started.
---> If my local networks are reachable, but the remote host is not, then there's a problem with the remote host
---> Check router (ping another remote network like facebook or twitter)... if icmp is blocked, ping will not work, try andother tool... e.g. tracerout.

-- traceroute / tracepath - examine network rout
---> ping tests an end point, but doesn't tell you anything about the path or route the network packets take.
---> to examine the route use the traceroute command.  
---> tracerout hostname - translates ip addresses into hostnames
---> tracerout -n hostname - checks if there's an issue in the dns by checking the hostname 
---> check for network conjestion on that router.
---> If there's an * it means nop reply.

-- netstat - display network statistics
	-n - Display numerical addresses and ports
	-i - Display a list of network interfaces
	-r - Display the route table (netstat -rn)
	-p - Display the PIF and program used
	-l - Display listening sockets (netstats -nlp)
	-t - Limit the output to TCP (netstat -ntlp)
	-u - Limit output to UDP (netstat -nulp)

-- tcpdump - analyse network traffic  
---> When you need to examin the content of network traffic to ensure payloads are delivered.
---> To make sure the data is reaching the destination, use tcpdump
	-n - Display numerical addresses and ports
	-A - Display ASCII (text) output
	-v - Verbose mode
	-vvv - More verbose mode

-- telnet - test if a port is open
---> telnet host_or_ip port
---> timeout - traffic getting dropped before it reaches the host or the port is not open.
---> connection refused - connection is being blocked by host.




29. SPECIAL MODES
Forces a process to start as the owner of the file, regardles of who executed the file.
-- umask - command used to set file creation mask.
-- SETUID = Set User ID upon execution.
--> When a process is started, it is run using the starting user's UID & GID.
--> if you do ls on a file ==> <-rwsr-xr-x > == the 's' in the OWNER perms.
--> files like /etc/passwd, ping (to access network devices), chsh(allows users to change their shell) need root privilages to access other files (like /etc/shadow). 
--> for e.g. THe CHSH command allows a user to change their shell, it requires an update to the /etc/passwd which can only be edited to the root user. 
--> If an attecker accesses the system they look for files set to SETUID root, since they run as root they are an attack surface for privilege escalation attacks.
--> SECURITY UNIX - does not honor setuid on .sh scripts, if you execute the a file with setuid it runs as you.

-- Octal Permissions
To determine setuid, setgid, and sticky, 
--> 	setuid	setgid	sticky
	0	0	0	Value for off
	1 	1	1	Binary value on
	4	2	1	Base 10 value for on
--> Add using chmod
e.g. chmod u+s /filename
     chmod 4755 filename
--> Remove using chmod
e.g. chmod u-s	/filename
     chmod 0755 /filename
--> to find all file that have setuid - Look for files that can be edited by anyone(755 good, 775 bad 777 very bad) except the owner of the file.
e.g. find / -perm /4000
     find / -perm +4000 -ls

-- SETGID Set Group ID upon execution.
Forces a program to run with the group privileges of the file, rather than the group privileges of the user of the file.
--> If you do ls on a file ==> <-rwxr-sr-x> the 's' in the GROUP perms.
--> The /usr/bin/wall command uses setgid, it displays a message to the terminal of users that are logged in the system.
--> Since all the files that represent the users terninal are in the "tty" group, and the "tty" group has write permissions on those files, anyone using the wall command is allowed to write to those terminals, because that process is running with tty privileges.
--> setdid on DIRECTORIES causes new files & directories to inherit the group of the directory.
--> It is not retroactive - only new files will inherit the perms.
--> Find Setgid files
e.g. find / -perm /2000 -ls
     find / -perm +2000 -ls --older style
--> Adding Setgid 
e.g. chmod g+s /filename
     chmod 2755 /filename
--> Removing Setgid
e.g. chmod g-s /filename
     chmod 0755 /filename

--> Adding the SETUID & SETGID
e.g. chmod ug+s /filename
     chmod 6755 /filename

-- Suing an INTEGRITY CHECKER
- Find, Tripwire, AIDE (Advanced Intrusion Detection Environment), OSSEC, Samhain, Package Managers

-- The Sticky Bit
Used on a directory to only allow the file, directory, or root user owner to rename or rename a file.
Without sticky bit (777 dir) allows anyone to delete anything in the dir.
--> If you do ls on the file ==> <drwxrwxrwt> the 't' in the DIR OTHER perms.
--> Adding Sticky Bit
e.g. chmod o+t /dir
     chmod 1777 /dir
-- Removing Sticky Bit
e.g. chmod 0-t /dir
     chmod 0777 /dir

-- Reading ls Output
--> A capitalised special permission means the underlying normal permission is not set.
--> A lowercase special permission means the underlying normal permission is set.


30. Shell Scripting
-- Scripts
--> Contain a series of commands.
--> An interpreter executes commands in the script.
--> Anything you can type at the command line, you can put in a script.
--> Great for automating tasks.
--> If scripts dont contain a shebang, the commands are executed using your shell.
-- SHEBANG
--> #!/usr/bin/python, #!/usr/bin/bash ...

-- Variabels
--> Storage locations that have a name
--> Name-value pairs
--> Syntax - VAR_NAME="Value"
--> Case sensitive

-- Positional Parameters
--> The parameters after the .sh
e.g. ./script.sh param1 param2 paramN - will mean $1 $2 $N when the script executes
--> $@ is a special parameter that means all the parameters. --see example_script.sh

-- Accepting User Input (STDIN)
--> The read command accepts STDIN
e.g. read -p "PROMPT" VAR_NAME


31. COMMAND LINE KUNG FU

-- Tab completion
-- Repeate as Root
-- RERUN STARTING WITH A STRING
-- REUSE ARGUMENTS
-- STRIP OUT COMMENTS AND BLANK LINES
-- REUSE LAST ITEM FROM PREVIOUS COMMAND
 
